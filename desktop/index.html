<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Santiago Metro Escape v4</title>
  <style>
    html, body {
      margin: 0; height: 100%;
      background: #05080E; color: #E8F1FF;
      overflow: hidden;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
    }
    #wrap { position: fixed; inset: 0; display: grid; place-items: center; }
    canvas {
      width: min(96vw, 1120px);
      aspect-ratio: 14 / 10;
      background: #000;
      border-radius: 14px;
      border: 1px solid rgba(232,241,255,0.14);
      box-shadow: 0 14px 42px rgba(0,0,0,0.40);
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }
    .hint {
      position: fixed; left: 50%; transform: translateX(-50%);
      bottom: 14px; font-size: 12px; opacity: 0.88;
      padding: 8px 12px; border-radius: 999px;
      background: rgba(7,12,18,0.55);
      border: 1px solid rgba(232,241,255,0.14);
      backdrop-filter: blur(6px);
      max-width: min(980px, 92vw);
      text-align: center;
    }
  </style>
</head>
<body>
  <div id="wrap"><canvas id="c" width="980" height="700"></canvas></div>
  <div class="hint">
    Move: WASD / Arrows • Support Power: Space • Help: H • Mute: M • Start/Restart: Enter
  </div>

<script>
(() => {
  const c = document.getElementById("c");
  const ctx = c.getContext("2d");

  const W = c.width, H = c.height;

  // Pac-style readable scale
  const TILE = 28;
  const COLS = Math.floor(W / TILE); // 35
  const ROWS = Math.floor(H / TILE); // 25

  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const rand  = (a,b)=>a+Math.random()*(b-a);
  const dist  = (ax,ay,bx,by)=>Math.hypot(ax-bx, ay-by);

  // Input
  const keys = new Set();
  addEventListener("keydown", (e)=>{
    const k = (e.key===" " ? "space" : e.key.toLowerCase());
    keys.add(k);
    if (["arrowup","arrowdown","arrowleft","arrowright"," "].includes(e.key)) e.preventDefault();
  });
  addEventListener("keyup", (e)=>{
    const k = (e.key===" " ? "space" : e.key.toLowerCase());
    keys.delete(k);
  });

  // Audio
  let audioCtx = null, muted = false;
  function ensureAudio(){ if(!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)(); }
  function sfx(freq=440, dur=0.06, vol=0.05, type="square", slide=0){
    if(muted) return;
    try{
      ensureAudio();
      const t0=audioCtx.currentTime;
      const o=audioCtx.createOscillator();
      const g=audioCtx.createGain();
      o.type=type;
      o.frequency.setValueAtTime(freq, t0);
      if(slide) o.frequency.linearRampToValueAtTime(freq+slide, t0+dur);
      g.gain.setValueAtTime(vol, t0);
      g.gain.exponentialRampToValueAtTime(0.0001, t0+dur);
      o.connect(g); g.connect(audioCtx.destination);
      o.start(t0); o.stop(t0+dur);
    }catch{}
  }

  // Simple loop
  const music = { bpm: 132, timer: 0, step: 0,
    lead:[0,2,4,7, 4,2,0,-3, 0,2,4,9, 7,4,2,0],
    bass:[-12,-12,-10,-10, -12,-12,-15,-15, -12,-12,-10,-10, -12,-12,-15,-15]
  };
  function noteHz(semi){ return 440*Math.pow(2, semi/12); }
  function musicTick(){
    if(muted) return;
    ensureAudio();
    const base=-9, st=music.step%16;
    sfx(noteHz(base+music.lead[st]), 0.07, 0.020, "square", 0);
    if(st%2===0) sfx(noteHz(base-12+music.bass[st]), 0.10, 0.026, "triangle", 0);
  }

  // State
  const STATE = { TITLE:"TITLE", WEST:"WEST", EAST:"EAST", GAMEOVER:"GAMEOVER" };
  let state = STATE.TITLE;
  let showHelp = true;

  // Tiles
  // # wall
  // . dot
  // O support pellet
  // M metro
  // S safe
  // H bank/home
  // W wage
  // R road (bus path)
  // T tree
  // A house (decoration tile, still walkable)
  const T = {
    FLOOR:0, WALL:1, DOT:2, SUPPORT:3, METRO:4, SAFE:5, HOME:6, WAGE:7,
    ROAD:8, TREE:9, HOUSE:10
  };

  const PAL = {
    ui:"#E8F1FF",
    uiDim:"rgba(232,241,255,0.75)",
    westFloor:"#0C1626",
    eastFloor:"#081D2D",
    westWall:"#3A2E63",
    eastWall:"#184E77",
    neon:"rgba(127,177,255,0.35)",
    dot:"#CFE3FF",
    wage:"#FFD66B",
    support:"#7CFFB5",
    safe:"#7CFFB5",
    metro:"#7FB1FF",
    road:"#1A263A",
    roadLine:"rgba(255,214,107,0.55)",
    tree:"#66D6FF",
    house:"#FF8ED6",
  };

  function rr(x,y,w,h,r){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    ctx.closePath();
  }

  // A simpler, classic interconnected maze (two wrap tunnels mid-left and mid-right)
  // Note: border is walls. There are loops everywhere. No linear corridors.
  function parse(lines){
    const m=[];
    for(let y=0;y<ROWS;y++){
      const row=[];
      const line=(lines[y]||"").padEnd(COLS," ");
      for(let x=0;x<COLS;x++){
        const ch=line[x];
        let v=T.FLOOR;
        if(ch==="#") v=T.WALL;
        else if(ch===".") v=T.DOT;
        else if(ch==="O") v=T.SUPPORT;
        else if(ch==="M") v=T.METRO;
        else if(ch==="S") v=T.SAFE;
        else if(ch==="H") v=T.HOME;
        else if(ch==="W") v=T.WAGE;
        else if(ch==="R") v=T.ROAD;
        else if(ch==="T") v=T.TREE;
        else if(ch==="A") v=T.HOUSE;
        row.push(v);
      }
      m.push(row);
    }
    return m;
  }

  // WEST layout (home side). Road loop included for buses.
  const westLines = [
    "###################################",
    "#S....A....#########....A....S....#",
    "#.###.###..#.......#..###.###.###.#",
    "#.O.#.....#..###.#..#.....#..O.#..#",
    "#.###.###.#..#.#.#..#.###.###.###.#",
    "#.....#...#..#.#.#..#...#.....#...#",
    "###.###.###..#.#.###.###.###.###.##",
    "#...#.....#.......#.....#.....#...#",
    "#.###.###.#####.#####.###.###.###.#",
    "#.....#.....#...#...#.....#.....#.#",
    "#.###.#####.#.###.###.#####.###.#.#",
    "#...#.......#...#.#...#.......#...#",
    "##R#R###.#######.#.#######.###R#R##",
    "#...#...#.....#.....#.....#...#...#",
    "#.###.###.###.#####.###.###.###.###",
    "#.#..O....#...#...#...#....O..#...#",
    "#.###.###.###.#.#.###.###.###.###.#",
    "#...#.....#...#.#...#.....#.....#.#",
    "###.#.#####.###.###.#####.#.###.#.#",
    "#...#.....#...#...#.....#.#...#...#",
    "#.###.###.###.###.###.###.###.###.#",
    "#..H..#.......#.....#.......#..T..#",
    "#.###.#####.###.###.#####.###.###.#",
    "#.....T.....#....M....#.....A.....#",
    "###################################",
  ];

  // EAST layout (work side). Similar connectivity, more W wages.
  const eastLines = [
    "###################################",
    "#S....A....#########....A....S....#",
    "#.###.###..#.......#..###.###.###.#",
    "#.O.#.....#..###.#..#.....#..O.#..#",
    "#.###.###.#..#.#.#..#.###.###.###.#",
    "#.....#...#..#.#.#..#...#.....#...#",
    "###.###.###..#.#.###.###.###.###.##",
    "#...#.....#.......#.....#.....#...#",
    "#.###.###.#####.#####.###.###.###.#",
    "#.....#.....#...#...#.....#.....#.#",
    "#.###.#####.#.###.###.#####.###.#.#",
    "#..W#..W....#...#.#...#....W..#..W#",
    "##R#R###.#######.#.#######.###R#R##",
    "#...#...#.....#.....#.....#...#...#",
    "#.###.###.###.#####.###.###.###.###",
    "#.#..O....#...#...#...#....O..#...#",
    "#.###.###.###.#.#.###.###.###.###.#",
    "#...#.....#...#.#...#.....#.....#.#",
    "###.#.#####.###.###.#####.#.###.#.#",
    "#...#.....#...#...#.....#.#...#...#",
    "#.###.###.###.###.###.###.###.###.#",
    "#.....#.......#.....#.......#.....#",
    "#.###.#####.###.###.#####.###.###.#",
    "#.....T.....#....M....#.....T.....#",
    "###################################",
  ];

  const west = parse(westLines);
  const east = parse(eastLines);

  function curMap(){ return (state===STATE.WEST) ? west : east; }
  function tileAt(m,x,y){ return (m[y] && m[y][x]!==undefined) ? m[y][x] : T.WALL; }
  function isWall(m,x,y){ return tileAt(m,x,y)===T.WALL; }

  // Wrap tunnels at row 12 (0-indexed), by making x=0 and x=COLS-1 walls but we teleport across when moving through the openings.
  const WRAP_ROW = 12;

  function canMove(m,x,y){
    if(y<=0 || y>=ROWS-1) return false;
    if(x<=0 || x>=COLS-1) return false; // borders are walls
    return !isWall(m,x,y);
  }

  function findTile(m, tval){
    for(let y=0;y<ROWS;y++) for(let x=0;x<COLS;x++) if(m[y][x]===tval) return {x,y};
    return {x:1,y:1};
  }

  const depot = { x: 17, y: 12 };
  const westHome = findTile(west, T.HOME);
  const westMetro = findTile(west, T.METRO);
  const eastMetro = findTile(east, T.METRO);

  // Player
  const player = {
    x: westHome.x, y: westHome.y,
    px:0, py:0,
    hp:100, maxHp:100,
    speed: 7.2,
    carried: 0,
    score: 0,
    invuln: 0,
    power: { active:false, t:0, dur:7.0 },
  };
  let banked = 0;

  // Ghosts
  function mkGhost(name, color, speed, start){
    return {
      name, color, speed,
      x: start.x, y: start.y, px:0, py:0,
      vx:0, vy:0, acc:0,
      mode:"CHASE",   // CHASE, FRIGHT, EATEN
      eatenTimer: 0,
      lastDir: {dx:0,dy:0},
    };
  }

  const ghosts = [
    mkGhost("SMOG",   "#7CFFB5", 4.15, {x:depot.x-1,y:depot.y}),
    mkGhost("SIREN",  "#FFD66B", 4.35, {x:depot.x+1,y:depot.y}),
    mkGhost("HEAT",   "#FF6B87", 4.05, {x:depot.x,y:depot.y-1}),
    mkGhost("STRESS", "#7FB1FF", 4.45, {x:depot.x,y:depot.y+1}),
  ];

  // Buses follow ROAD tiles only, obeying collision rules
  function mkBus(color, start){
    return { color, x:start.x, y:start.y, px:0, py:0, acc:0, lastDir:{dx:1,dy:0} };
  }
  const buses = [
    mkBus("rgba(255,107,135,0.95)", {x:2, y:12}),
    mkBus("rgba(255,214,107,0.95)", {x:COLS-3, y:12}),
  ];

  // Difficulty tuning
  const level = { dps: 18, regen: 7.0, safeRegenMul: 2.2, safeDmgMul: 0.55, goalWages: 4 };

  // Helpers
  function isSafe(m,x,y){
    const t = tileAt(m,x,y);
    return t===T.SAFE || t===T.HOME;
  }

  function drawBackdrop(side){
    const sky = ctx.createLinearGradient(0,0,0,H);
    sky.addColorStop(0, side===STATE.WEST ? "#2B3E74" : "#234F86");
    sky.addColorStop(0.58, side===STATE.WEST ? "#0B1A2E" : "#0A203A");
    sky.addColorStop(1, "#05080E");
    ctx.fillStyle=sky;
    ctx.fillRect(0,0,W,H);

    // Andes
    ctx.fillStyle="rgba(0,0,0,0.33)";
    ctx.beginPath();
    ctx.moveTo(0,160);
    const peaks=[[90,120],[170,155],[270,118],[380,165],[500,115],[610,175],[720,125],[830,180],[980,140]];
    for(const [x,y] of peaks) ctx.lineTo(x,y);
    ctx.lineTo(W,210); ctx.lineTo(0,210); ctx.closePath();
    ctx.fill();

    // skyline
    const baseY=220, n=58;
    for(let i=0;i<n;i++){
      const bw=Math.floor(rand(10,28));
      const bh=Math.floor(rand(18, side===STATE.WEST ? 90 : 150));
      const bx=Math.floor(rand(-20, W+20));
      ctx.fillStyle= side===STATE.WEST ? "rgba(0,0,0,0.24)" : "rgba(0,0,0,0.20)";
      ctx.fillRect(bx, baseY-bh, bw, bh);
    }

    // metro line ribbon
    ctx.save();
    ctx.globalAlpha=0.14;
    ctx.fillStyle="rgba(127,177,255,0.7)";
    ctx.fillRect(0, 240, W, 8);
    ctx.restore();
  }

  function drawTile(m,x,y){
    const t=tileAt(m,x,y);
    const gx=x*TILE, gy=y*TILE;

    // floor base
    ctx.fillStyle = (state===STATE.WEST) ? PAL.westFloor : PAL.eastFloor;
    ctx.fillRect(gx,gy,TILE,TILE);

    // ROAD
    if(t===T.ROAD){
      ctx.fillStyle = PAL.road;
      ctx.fillRect(gx,gy,TILE,TILE);
      ctx.strokeStyle = PAL.roadLine;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(gx+4, gy+TILE/2);
      ctx.lineTo(gx+TILE-4, gy+TILE/2);
      ctx.stroke();
      return;
    }

    // WALL
    if(t===T.WALL){
      const wall = (state===STATE.WEST) ? PAL.westWall : PAL.eastWall;
      ctx.fillStyle=wall;
      ctx.fillRect(gx,gy,TILE,TILE);

      // bevel
      ctx.fillStyle="rgba(255,255,255,0.10)";
      ctx.fillRect(gx+2,gy+2,TILE-4,2);
      ctx.fillRect(gx+2,gy+2,2,TILE-4);
      ctx.fillStyle="rgba(0,0,0,0.30)";
      ctx.fillRect(gx+2,gy+TILE-4,TILE-4,2);
      ctx.fillRect(gx+TILE-4,gy+2,2,TILE-4);

      // neon edge glow
      ctx.save();
      ctx.globalAlpha=0.22;
      ctx.strokeStyle=PAL.neon;
      ctx.lineWidth=2;
      ctx.beginPath();
      if(!isWall(m,x,y-1)) { ctx.moveTo(gx+3,gy+3); ctx.lineTo(gx+TILE-3,gy+3); }
      if(!isWall(m,x,y+1)) { ctx.moveTo(gx+3,gy+TILE-3); ctx.lineTo(gx+TILE-3,gy+TILE-3); }
      if(!isWall(m,x-1,y)) { ctx.moveTo(gx+3,gy+3); ctx.lineTo(gx+3,gy+TILE-3); }
      if(!isWall(m,x+1,y)) { ctx.moveTo(gx+TILE-3,gy+3); ctx.lineTo(gx+TILE-3,gy+TILE-3); }
      ctx.stroke();
      ctx.restore();
      return;
    }

    // DOT
    if(t===T.DOT){
      ctx.save();
      ctx.globalAlpha=0.88;
      ctx.fillStyle=PAL.dot;
      ctx.beginPath();
      ctx.arc(gx+TILE/2, gy+TILE/2, 2.1, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
      return;
    }

    // SUPPORT (power pellet)
    if(t===T.SUPPORT){
      const pulse=0.55+0.45*Math.sin(now*5.0);
      ctx.save();
      ctx.globalAlpha=0.18;
      ctx.fillStyle=PAL.support;
      ctx.fillRect(gx+2,gy+2,TILE-4,TILE-4);
      ctx.globalAlpha=0.95;
      ctx.fillStyle=PAL.support;
      ctx.beginPath();
      ctx.arc(gx+TILE/2, gy+TILE/2, 7.8 + 1.2*pulse, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
      return;
    }

    // SAFE
    if(t===T.SAFE){
      ctx.save();
      ctx.globalAlpha=0.18;
      ctx.fillStyle=PAL.safe;
      ctx.fillRect(gx+2,gy+2,TILE-4,TILE-4);
      ctx.globalAlpha=0.85;
      ctx.strokeStyle="rgba(124,255,181,0.95)";
      ctx.lineWidth=2;
      ctx.beginPath();
      ctx.arc(gx+TILE/2, gy+TILE/2, 9.0, 0, Math.PI*2);
      ctx.stroke();
      ctx.restore();
      return;
    }

    // WAGE
    if(t===T.WAGE){
      ctx.save();
      ctx.globalAlpha=0.20;
      ctx.fillStyle=PAL.wage;
      ctx.fillRect(gx+3,gy+3,TILE-6,TILE-6);
      ctx.globalAlpha=0.95;
      ctx.fillStyle=PAL.wage;
      ctx.beginPath();
      ctx.arc(gx+TILE/2, gy+TILE/2, 6.2, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
      return;
    }

    // TREE
    if(t===T.TREE){
      ctx.save();
      ctx.globalAlpha=0.18;
      ctx.fillStyle=PAL.tree;
      ctx.fillRect(gx+3,gy+3,TILE-6,TILE-6);
      ctx.globalAlpha=0.90;
      ctx.fillStyle=PAL.tree;
      ctx.beginPath(); ctx.arc(gx+TILE/2, gy+12, 7.5, 0, Math.PI*2); ctx.fill();
      ctx.fillRect(gx+TILE/2-1, gy+15, 2, 10);
      ctx.restore();
      return;
    }

    // HOUSE (walkable decoration)
    if(t===T.HOUSE){
      ctx.save();
      ctx.globalAlpha=0.16;
      ctx.fillStyle=PAL.house;
      ctx.fillRect(gx+2,gy+2,TILE-4,TILE-4);
      ctx.globalAlpha=0.92;
      ctx.fillStyle=PAL.house;
      ctx.fillRect(gx+9, gy+15, 10, 9);
      ctx.beginPath();
      ctx.moveTo(gx+8, gy+15);
      ctx.lineTo(gx+14, gy+10);
      ctx.lineTo(gx+20, gy+15);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
      return;
    }

    // HOME
    if(t===T.HOME){
      ctx.save();
      ctx.globalAlpha=0.14;
      ctx.fillStyle="#E8F1FF";
      ctx.fillRect(gx+2,gy+2,TILE-4,TILE-4);
      ctx.globalAlpha=0.92;
      ctx.fillStyle="#E8F1FF";
      ctx.fillRect(gx+9, gy+15, 10, 9);
      ctx.beginPath();
      ctx.moveTo(gx+8, gy+15);
      ctx.lineTo(gx+14, gy+10);
      ctx.lineTo(gx+20, gy+15);
      ctx.closePath();
      ctx.fill();

      ctx.globalAlpha=0.90;
      ctx.fillStyle="rgba(7,12,18,0.65)";
      rr(gx-6, gy-12, TILE+12, 16, 8); ctx.fill();
      ctx.fillStyle="#E8F1FF";
      ctx.font="bold 11px ui-monospace, monospace";
      ctx.textAlign="center"; ctx.textBaseline="middle";
      ctx.fillText("BANK", gx+TILE/2, gy-4);
      ctx.restore();
      return;
    }

    // METRO
    if(t===T.METRO){
      const cx=gx+TILE/2, cy=gy+TILE/2;
      const pulse=0.55+0.45*Math.sin(now*5.1);
      ctx.save();
      ctx.globalAlpha=0.22+0.10*pulse;
      ctx.fillStyle="rgba(127,177,255,0.65)";
      ctx.beginPath(); ctx.arc(cx,cy,18,0,Math.PI*2); ctx.fill();

      ctx.globalAlpha=1;
      ctx.fillStyle="rgba(7,12,18,0.82)";
      rr(gx-18, gy-10, TILE+36, TILE+22, 12); ctx.fill();
      ctx.strokeStyle="rgba(127,177,255,0.75)";
      ctx.lineWidth=2; ctx.stroke();

      ctx.fillStyle="rgba(127,177,255,0.22)";
      rr(gx-10, gy-8, TILE+20, 18, 10); ctx.fill();
      ctx.fillStyle="#E8F1FF";
      ctx.font="bold 12px ui-monospace, monospace";
      ctx.textAlign="center"; ctx.textBaseline="middle";
      ctx.fillText("METRO", cx, gy+2);
      ctx.restore();
      return;
    }
  }

  function drawMap(){
    const m=curMap();
    for(let y=0;y<ROWS;y++){
      for(let x=0;x<COLS;x++){
        drawTile(m,x,y);
      }
    }

    // draw wrap tunnel indicators
    ctx.save();
    ctx.globalAlpha=0.20;
    ctx.fillStyle="rgba(232,241,255,0.7)";
    ctx.fillRect(0, WRAP_ROW*TILE+TILE/2-2, 18, 4);
    ctx.fillRect(W-18, WRAP_ROW*TILE+TILE/2-2, 18, 4);
    ctx.restore();
  }

  function drawPlayer(){
    const x=player.px, y=player.py;
    const pulse=0.70+0.30*Math.sin(now*9);

    ctx.save();
    // shadow
    ctx.globalAlpha=0.22;
    ctx.fillStyle="#000";
    ctx.beginPath();
    ctx.ellipse(x+TILE/2, y+TILE/2+10, 12, 4.6, 0, 0, Math.PI*2);
    ctx.fill();

    // body
    ctx.globalAlpha=0.95;
    ctx.fillStyle="rgba(59,228,197,0.95)";
    rr(x+5, y+5, TILE-10, TILE-10, 10); ctx.fill();

    ctx.globalAlpha=0.16+0.10*pulse;
    ctx.fillStyle="#FFF";
    rr(x+9, y+8, TILE-18, TILE-18, 10); ctx.fill();

    // power aura
    if(player.power.active){
      const r=52+7*Math.sin(now*5);
      ctx.globalAlpha=0.11;
      ctx.fillStyle=PAL.support;
      ctx.beginPath(); ctx.arc(x+TILE/2,y+TILE/2,r,0,Math.PI*2); ctx.fill();
      ctx.globalAlpha=0.18;
      ctx.strokeStyle="rgba(232,241,255,0.30)";
      ctx.lineWidth=2;
      ctx.beginPath(); ctx.arc(x+TILE/2,y+TILE/2,r,0,Math.PI*2); ctx.stroke();
    }

    // invuln blink
    if(player.invuln>0){
      ctx.globalAlpha=0.35+0.35*Math.sin(now*24);
      ctx.fillStyle="#E8F1FF";
      ctx.fillRect(x+TILE/2-1, y+2, 2, 6);
    }

    ctx.restore();
  }

  function drawGhost(g){
    const x=g.px, y=g.py;
    const frightened = (g.mode==="FRIGHT");
    const eaten = (g.mode==="EATEN");

    ctx.save();

    // shadow
    ctx.globalAlpha=0.20;
    ctx.fillStyle="#000";
    ctx.beginPath();
    ctx.ellipse(x+TILE/2, y+TILE/2+10, 12, 4.6, 0, 0, Math.PI*2);
    ctx.fill();

    // body
    ctx.globalAlpha=0.98;
    ctx.fillStyle = eaten ? "rgba(232,241,255,0.35)" : frightened ? "rgba(232,241,255,0.80)" : g.color;
    rr(x+5, y+6, TILE-10, TILE-10, 12); ctx.fill();
    ctx.fillRect(x+5, y+TILE-9, TILE-10, 6);

    // eyes
    ctx.globalAlpha=0.90;
    ctx.fillStyle="rgba(0,0,0,0.30)";
    ctx.beginPath(); ctx.arc(x+TILE/2-6, y+TILE/2-1, 3.4, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(x+TILE/2+6, y+TILE/2-1, 3.4, 0, Math.PI*2); ctx.fill();

    const pxo=clamp(g.lastDir.dx*1.2,-1.2,1.2);
    const pyo=clamp(g.lastDir.dy*1.2,-1.2,1.2);
    ctx.globalAlpha=0.85;
    ctx.fillStyle= frightened ? "#0B1A2E" : "#E8F1FF";
    ctx.beginPath(); ctx.arc(x+TILE/2-6+pxo, y+TILE/2-1+pyo, 1.5, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(x+TILE/2+6+pxo, y+TILE/2-1+pyo, 1.5, 0, Math.PI*2); ctx.fill();

    // label (tiny) for readability
    ctx.globalAlpha=0.55;
    ctx.fillStyle="rgba(7,12,18,0.55)";
    rr(x+1, y-10, TILE-2, 12, 6); ctx.fill();
    ctx.globalAlpha=0.85;
    ctx.fillStyle="#E8F1FF";
    ctx.font="10px ui-monospace, monospace";
    ctx.textAlign="center"; ctx.textBaseline="middle";
    ctx.fillText(g.name[0], x+TILE/2, y-4);

    ctx.restore();
  }

  function drawBus(b){
    const x=b.px, y=b.py;
    ctx.save();
    ctx.globalAlpha=0.90;
    ctx.fillStyle="rgba(0,0,0,0.30)";
    ctx.beginPath();
    ctx.ellipse(x+TILE/2, y+TILE/2+10, 16, 5, 0, 0, Math.PI*2);
    ctx.fill();

    ctx.fillStyle=b.color;
    rr(x-8, y+6, TILE+16, TILE-12, 10); ctx.fill();

    ctx.globalAlpha=0.20;
    ctx.fillStyle="#FFF";
    rr(x-4, y+10, TILE+8, 10, 6); ctx.fill();

    ctx.globalAlpha=0.92;
    ctx.fillStyle="#111";
    ctx.fillRect(x-2, y+TILE-10, 6, 4);
    ctx.fillRect(x+TILE-4, y+TILE-10, 6, 4);
    ctx.restore();
  }

  function drawHUD(){
    ctx.save();
    ctx.fillStyle="rgba(5,8,14,0.66)";
    ctx.fillRect(0,0,W,70);

    const side = (state===STATE.WEST) ? "WEST (Home)" : "EAST (Work)";
    ctx.fillStyle=PAL.ui;
    ctx.font="16px ui-monospace, monospace";
    ctx.textBaseline="middle";
    ctx.fillText(`SANTIAGO METRO ESCAPE  |  LEVEL 1  |  ${side}`, 14, 18);

    ctx.fillStyle=PAL.uiDim;
    ctx.font="13px ui-monospace, monospace";
    ctx.fillText(`Goal: Deliver ${level.goalWages} wages. Carried: ${player.carried}  |  Banked: ${banked}`, 14, 44);

    // health bar
    const hbX=520, hbY=16, hbW=240, hbH=18;
    ctx.strokeStyle="rgba(232,241,255,0.20)";
    ctx.lineWidth=2;
    rr(hbX,hbY,hbW,hbH,9); ctx.stroke();
    const p=clamp(player.hp/player.maxHp,0,1);
    ctx.fillStyle = p>0.6 ? "rgba(59,228,197,0.95)" : p>0.3 ? "rgba(255,214,107,0.95)" : "rgba(255,77,109,0.95)";
    rr(hbX+2,hbY+2,(hbW-4)*p,hbH-4,8); ctx.fill();
    ctx.fillStyle=PAL.uiDim;
    ctx.fillText("Allostatic Load", hbX+4, hbY+hbH+16);

    // power status
    ctx.fillStyle=PAL.ui;
    ctx.font="14px ui-monospace, monospace";
    const powLeft = player.power.active ? `${Math.ceil(player.power.dur-player.power.t)}s` : "none";
    ctx.fillText(`Support power: ${powLeft}`, 790, 18);

    ctx.restore();
  }

  function drawHelp(){
    if(!showHelp) return;
    const bw=860, bh=330;
    const x=(W-bw)/2, y=(H-bh)/2;
    ctx.save();
    ctx.fillStyle="rgba(7,12,18,0.78)";
    rr(x,y,bw,bh,16); ctx.fill();
    ctx.strokeStyle="rgba(232,241,255,0.20)";
    ctx.lineWidth=2; ctx.stroke();

    ctx.fillStyle="#E8F1FF";
    ctx.font="28px ui-monospace, monospace";
    ctx.textAlign="center"; ctx.textBaseline="middle";
    ctx.fillText("How to play", W/2, y+42);

    ctx.fillStyle="rgba(232,241,255,0.78)";
    ctx.font="15px ui-monospace, monospace";
    ctx.textAlign="left"; ctx.textBaseline="top";
    const lines=[
      "You commute between WEST (home) and EAST (work) through the METRO.",
      "Pick up WAGES (gold) in the EAST and BANK them at HOME in the WEST.",
      "",
      "Ghosts actively hunt you using shortest-path logic.",
      "Support Power (Space) frightens ghosts for a few seconds.",
      "While frightened, touching a ghost sends it back to the depot to respawn.",
      "",
      "Buses only travel on ROAD tiles (they obey walls).",
      "Safe zones heal faster. Health represents allostatic load on the brain.",
      "",
      "Press H to toggle this overlay."
    ];
    let yy=y+78, xx=x+36;
    for(const ln of lines){ ctx.fillText(ln, xx, yy); yy+=22; }
    ctx.fillStyle="rgba(255,214,107,0.90)";
    ctx.textAlign="center";
    ctx.fillText("Press H to close", W/2, y+bh-24);
    ctx.restore();
  }

  function drawScanlines(){
    ctx.save();
    ctx.globalAlpha=0.13;
    for(let y=0;y<H;y+=3){
      ctx.fillStyle="rgba(0,0,0,0.35)";
      ctx.fillRect(0,y,W,1);
    }
    ctx.restore();
  }

  function overlay(title, lines){
    ctx.save();
    const bw=760, bh=320;
    const x=(W-bw)/2, y=(H-bh)/2;
    ctx.fillStyle="rgba(7,12,18,0.78)";
    rr(x,y,bw,bh,16); ctx.fill();
    ctx.strokeStyle="rgba(232,241,255,0.20)";
    ctx.lineWidth=2; ctx.stroke();

    ctx.fillStyle="#E8F1FF";
    ctx.font="34px ui-monospace, monospace";
    ctx.textAlign="center"; ctx.textBaseline="middle";
    ctx.fillText(title, W/2, y+62);

    ctx.fillStyle="rgba(232,241,255,0.78)";
    ctx.font="15px ui-monospace, monospace";
    let yy=y+118;
    for(const ln of lines){ ctx.fillText(ln, W/2, yy); yy+=22; }
    ctx.restore();
  }

  // Wrap tunnel: moving off left/right at WRAP_ROW teleports
  function tryWrap(nx, ny, dx){
    if(ny !== WRAP_ROW) return {nx, ny, wrapped:false};
    // openings are inside border at x=1 and x=COLS-2, but if player tries to step beyond, wrap
    if(dx < 0 && nx === 0)  return {nx: COLS-2, ny, wrapped:true};
    if(dx > 0 && nx === COLS-1) return {nx: 1, ny, wrapped:true};
    return {nx, ny, wrapped:false};
  }

  // Pickups and metro
  function handlePickups(){
    const m=curMap();
    const t = tileAt(m, player.x, player.y);

    if(t===T.DOT){
      m[player.y][player.x]=T.FLOOR;
      player.score += 2;
      sfx(720,0.03,0.020,"square",60);
    }

    if(t===T.WAGE){
      m[player.y][player.x]=T.FLOOR;
      player.carried += 1;
      player.score += 40;
      sfx(920,0.05,0.04,"square",80);
    }

    if(t===T.SUPPORT){
      m[player.y][player.x]=T.FLOOR;
      player.power.active=true;
      player.power.t=0;
      for(const g of ghosts){
        if(g.mode!=="EATEN") g.mode="FRIGHT";
      }
      sfx(660,0.10,0.05,"triangle",0);
      sfx(980,0.06,0.04,"square",0);
    }

    if(t===T.METRO){
      // travel
      if(state===STATE.WEST){
        state=STATE.EAST;
        player.x = eastMetro.x;
        player.y = eastMetro.y+1;
      } else {
        state=STATE.WEST;
        player.x = westMetro.x;
        player.y = westMetro.y-1;
      }
      // reposition ghosts near depot but not stuck
      for(const g of ghosts){
        g.x = depot.x + (Math.random()<0.5?-3:3);
        g.y = depot.y + (Math.random()<0.5?-2:2);
        g.acc=0; g.lastDir={dx:0,dy:0};
        if(g.mode==="EATEN") g.mode="CHASE";
      }
      sfx(320,0.08,0.04,"triangle",-60);
      sfx(520,0.06,0.04,"square",60);
    }

    if(state===STATE.WEST && t===T.HOME && player.carried>0){
      banked += player.carried;
      player.score += player.carried*80;
      player.carried = 0;

      if(banked >= level.goalWages){
        player.score += 350;
        banked = 0;
        sfx(740,0.09,0.05,"square",90);
        sfx(520,0.12,0.05,"triangle",0);
      } else {
        sfx(520,0.08,0.04,"triangle",0);
      }
    }
  }

  // BFS pathfinding to next step on shortest path
  // Returns first step direction from (sx,sy) to (tx,ty)
  function bfsNextStep(m, sx, sy, tx, ty){
    if(sx===tx && sy===ty) return {dx:0,dy:0};

    const qx = new Int16Array(COLS*ROWS);
    const qy = new Int16Array(COLS*ROWS);
    const prev = new Int32Array(COLS*ROWS);
    prev.fill(-1);

    const idx = (x,y)=>y*COLS+x;

    let head=0, tail=0;
    qx[tail]=sx; qy[tail]=sy; tail++;
    prev[idx(sx,sy)] = idx(sx,sy);

    const dirs = [{dx:1,dy:0},{dx:-1,dy:0},{dx:0,dy:1},{dx:0,dy:-1}];

    while(head<tail){
      const x=qx[head], y=qy[head]; head++;
      if(x===tx && y===ty) break;

      for(const d of dirs){
        let nx=x+d.dx, ny=y+d.dy;

        // ghost wrap on tunnel row
        if(ny===WRAP_ROW && nx===0) nx=COLS-2;
        else if(ny===WRAP_ROW && nx===COLS-1) nx=1;

        if(ny<=0 || ny>=ROWS-1) continue;
        if(nx<=0 || nx>=COLS-1) continue;
        if(isWall(m,nx,ny)) continue;

        const ni=idx(nx,ny);
        if(prev[ni]!==-1) continue;
        prev[ni]=idx(x,y);
        qx[tail]=nx; qy[tail]=ny; tail++;
      }
    }

    const targetIndex = idx(tx,ty);
    if(prev[targetIndex]===-1){
      // no path, do nothing
      return {dx:0,dy:0};
    }

    // walk back from target to start to find first step
    let cur = targetIndex;
    while(true){
      const p = prev[cur];
      if(p===cur) break;
      if(p===idx(sx,sy)){
        const cx = cur % COLS;
        const cy = Math.floor(cur / COLS);
        const dx = cx - sx;
        const dy = cy - sy;
        // normalize wrap direction
        if(dy===0 && sy===WRAP_ROW){
          if(sx===1 && cx===COLS-2) return {dx:-1,dy:0};
          if(sx===COLS-2 && cx===1) return {dx:1,dy:0};
        }
        return {dx: clamp(dx,-1,1), dy: clamp(dy,-1,1)};
      }
      cur = p;
    }
    return {dx:0,dy:0};
  }

  // Ghost targeting personalities
  function ghostTarget(g){
    // EATEN returns to depot
    if(g.mode==="EATEN") return depot;

    // FRIGHT runs away to farthest corner-ish point relative to player
    if(g.mode==="FRIGHT"){
      const tx = (player.x < COLS/2) ? COLS-3 : 2;
      const ty = (player.y < ROWS/2) ? ROWS-3 : 2;
      return {x:tx, y:ty};
    }

    // CHASE personalities
    if(g.name==="SMOG"){
      // direct chase
      return {x:player.x, y:player.y};
    }
    if(g.name==="SIREN"){
      // ambush: aim 4 tiles ahead of player direction guess
      let dx=0,dy=0;
      if(keys.has("arrowleft")||keys.has("a")) dx=-1;
      else if(keys.has("arrowright")||keys.has("d")) dx=1;
      else if(keys.has("arrowup")||keys.has("w")) dy=-1;
      else if(keys.has("arrowdown")||keys.has("s")) dy=1;
      return {x: clamp(player.x+dx*4, 1, COLS-2), y: clamp(player.y+dy*4, 1, ROWS-2)};
    }
    if(g.name==="HEAT"){
      // cut-off: aim between player and metro (pressure commute)
      const m = (state===STATE.WEST) ? westMetro : eastMetro;
      return {x: clamp(Math.round((player.x+m.x)/2), 1, COLS-2), y: clamp(Math.round((player.y+m.y)/2), 1, ROWS-2)};
    }
    // STRESS: slightly jittery but still homing
    return {x: clamp(player.x + (Math.random()<0.5?1:-1), 1, COLS-2), y: player.y};
  }

  // Update ghosts using BFS shortest-path next step (real hunting)
  function updateGhosts(dt){
    const m=curMap();

    for(const g of ghosts){
      if(g.mode==="EATEN"){
        g.eatenTimer -= dt;
        if(g.eatenTimer<=0){
          g.mode="CHASE";
          g.x=depot.x; g.y=depot.y;
          g.acc=0;
        }
      }

      let spd = g.speed;
      if(g.mode==="FRIGHT") spd *= 0.72;
      if(g.mode==="EATEN") spd *= 1.55;

      g.acc += dt * spd;

      while(g.acc >= 1){
        g.acc -= 1;

        const tgt = ghostTarget(g);

        // compute best next step
        let step = bfsNextStep(m, g.x, g.y, tgt.x, tgt.y);

        // slight randomness for FRIGHT
        if(g.mode==="FRIGHT" && Math.random()<0.35){
          const opts = [{dx:1,dy:0},{dx:-1,dy:0},{dx:0,dy:1},{dx:0,dy:-1}].filter(d=>{
            let nx=g.x+d.dx, ny=g.y+d.dy;
            if(ny===WRAP_ROW && nx===0) nx=COLS-2;
            else if(ny===WRAP_ROW && nx===COLS-1) nx=1;
            return canMove(m,nx,ny);
          });
          if(opts.length) step = opts[(Math.random()*opts.length)|0];
        }

        // move
        let nx=g.x+step.dx, ny=g.y+step.dy;
        if(ny===WRAP_ROW && nx===0) nx=COLS-2;
        else if(ny===WRAP_ROW && nx===COLS-1) nx=1;

        if(canMove(m,nx,ny)){
          g.x=nx; g.y=ny;
          g.lastDir = step;
        }
      }

      g.px=g.x*TILE;
      g.py=g.y*TILE;
    }
  }

  // Buses: follow ROAD network with simple forward preference, no wall crossing
  function isRoad(m,x,y){ return tileAt(m,x,y)===T.ROAD; }
  function updateBuses(dt){
    const m=curMap();
    for(const b of buses){
      b.acc += dt * 3.0;
      while(b.acc >= 1){
        b.acc -= 1;

        // choose next road step, prefer continuing direction
        const dirs = [{dx:b.lastDir.dx,dy:b.lastDir.dy},{dx:1,dy:0},{dx:-1,dy:0},{dx:0,dy:1},{dx:0,dy:-1}];
        let chosen=null;
        for(const d of dirs){
          let nx=b.x+d.dx, ny=b.y+d.dy;

          // wrap only if on wrap row and road continues
          if(ny===WRAP_ROW && nx===0) nx=COLS-2;
          else if(ny===WRAP_ROW && nx===COLS-1) nx=1;

          if(ny<=0 || ny>=ROWS-1) continue;
          if(nx<=0 || nx>=COLS-1) continue;

          if(isRoad(m,nx,ny)){
            chosen={dx:d.dx,dy:d.dy, nx, ny};
            break;
          }
        }

        if(!chosen){
          // if dead end, turn around
          b.lastDir = {dx:-b.lastDir.dx, dy:-b.lastDir.dy};
          continue;
        }

        b.x=chosen.nx; b.y=chosen.ny;
        b.lastDir = {dx:chosen.dx, dy:chosen.dy};
      }

      b.px=b.x*TILE;
      b.py=b.y*TILE;
    }
  }

  // Player movement: grid-stepped, wrap tunnel works
  let moveAcc = 0;
  function updatePlayer(dt){
    const m=curMap();
    moveAcc += dt * player.speed;

    let dx=0,dy=0;
    if(keys.has("arrowleft")||keys.has("a")) dx=-1;
    else if(keys.has("arrowright")||keys.has("d")) dx=1;
    else if(keys.has("arrowup")||keys.has("w")) dy=-1;
    else if(keys.has("arrowdown")||keys.has("s")) dy=1;

    while(moveAcc>=1){
      moveAcc -= 1;

      let nx=player.x+dx, ny=player.y+dy;

      // allow tunnel wrap through border openings on WRAP_ROW
      if(ny===WRAP_ROW && nx===0) nx=COLS-2;
      else if(ny===WRAP_ROW && nx===COLS-1) nx=1;

      if((dx||dy) && canMove(m,nx,ny)){
        player.x=nx; player.y=ny;
        if(Math.random()<0.12) sfx(210,0.02,0.010,"square",0);
      }

      handlePickups();
    }

    player.px=player.x*TILE;
    player.py=player.y*TILE;
  }

  // Damage and power logic
  function applyDamage(dt){
    const m=curMap();
    if(player.invuln>0) player.invuln -= dt;

    if(player.power.active){
      player.power.t += dt;
      if(player.power.t >= player.power.dur){
        player.power.active=false;
        for(const g of ghosts){
          if(g.mode==="FRIGHT") g.mode="CHASE";
        }
      }
    }

    const pcx=player.px+TILE/2, pcy=player.py+TILE/2;

    // bus exposure (minor damage multiplier if standing too close)
    let busNear=false;
    for(const b of buses){
      const bx=b.px+TILE/2, by=b.py+TILE/2;
      if(dist(pcx,pcy,bx,by) < 46){ busNear=true; break; }
    }

    const safe = isSafe(m, player.x, player.y);

    // ghost collision
    const hitR=14;
    let hit=null;
    for(const g of ghosts){
      const gx=g.px+TILE/2, gy=g.py+TILE/2;
      if(dist(pcx,pcy,gx,gy) <= hitR){ hit=g; break; }
    }

    // powered: eat frightened ghost
    if(hit && player.power.active && hit.mode==="FRIGHT"){
      hit.mode="EATEN";
      hit.eatenTimer = 1.6;
      player.score += 120;
      player.invuln = 0.20;
      sfx(980,0.06,0.05,"square",120);
      return;
    }

    // take damage
    let dmgMul = 1.0;
    if(busNear) dmgMul *= 1.12;
    if(safe) dmgMul *= level.safeDmgMul;

    if(hit && player.invuln<=0 && hit.mode!=="EATEN"){
      player.hp -= level.dps * dmgMul * dt;
      player.invuln = 0.38;
      sfx(240,0.04,0.030,"square",-30);
    } else {
      // regen
      const regen = level.regen * (safe ? level.safeRegenMul : 1.0);
      player.hp += regen * dt;
    }

    player.hp = clamp(player.hp,0,player.maxHp);
    if(player.hp<=0){
      state=STATE.GAMEOVER;
      sfx(110,0.14,0.06,"square",-55);
    }
  }

  // Title / toggles
  function handleUI(dt){
    if(keys.has("m")){ keys.delete("m"); muted=!muted; sfx(muted?160:760,0.06,0.05,"square",0); }
    if(keys.has("h")){ keys.delete("h"); showHelp=!showHelp; sfx(620,0.04,0.03,"square", showHelp?40:-40); }

    if(keys.has("enter")){
      keys.delete("enter");
      if(state===STATE.TITLE){
        state=STATE.WEST;
        showHelp=false;
        try{ ensureAudio(); }catch{}
      } else if(state===STATE.GAMEOVER){
        resetAll();
        state=STATE.WEST;
        showHelp=false;
      }
    }

    if(keys.has("space") && (state===STATE.WEST||state===STATE.EAST)){
      // optional: allow manual trigger only if player currently has power pellet effect available?
      // For now, Space does nothing extra beyond collected Support. Keep it simple.
    }
  }

  function resetAll(){
    state=STATE.WEST;
    player.x=westHome.x; player.y=westHome.y;
    player.hp=100; player.carried=0; player.score=0; player.invuln=0;
    player.power.active=false; player.power.t=0;
    banked=0;

    // reset ghosts
    const starts = [{x:depot.x-1,y:depot.y},{x:depot.x+1,y:depot.y},{x:depot.x,y:depot.y-1},{x:depot.x,y:depot.y+1}];
    ghosts.forEach((g,i)=>{
      g.x=starts[i].x; g.y=starts[i].y;
      g.mode="CHASE";
      g.eatenTimer=0;
      g.acc=0;
      g.lastDir={dx:0,dy:0};
    });

    // buses start on road tiles
    buses[0].x=2; buses[0].y=WRAP_ROW;
    buses[0].lastDir={dx:1,dy:0}; buses[0].acc=0;
    buses[1].x=COLS-3; buses[1].y=WRAP_ROW;
    buses[1].lastDir={dx:-1,dy:0}; buses[1].acc=0;

    player.px=player.x*TILE; player.py=player.y*TILE;
  }

  // Pickups placement tweak: ensure dots exist in open areas for route feel
  function sprinkleDots(m){
    for(let y=1;y<ROWS-1;y++){
      for(let x=1;x<COLS-1;x++){
        if(m[y][x]===T.FLOOR && Math.random()<0.14) m[y][x]=T.DOT;
      }
    }
  }
  sprinkleDots(west);
  sprinkleDots(east);

  // Music update
  function updateMusic(dt){
    if(state===STATE.TITLE || state===STATE.GAMEOVER) return;
    if(!audioCtx || muted) return;
    const spb = 60/music.bpm;
    const stepDur = spb/4;
    music.timer += dt;
    while(music.timer>=stepDur){
      music.timer -= stepDur;
      music.step = (music.step+1)%16;
      musicTick();
    }
  }

  // Gameplay: bank wages in west, collect wages in east
  function enforceGoal(){
    // On EAST, keep at least a few wage tiles alive
    if(state===STATE.EAST){
      const m=east;
      let count=0;
      for(let y=1;y<ROWS-1;y++) for(let x=1;x<COLS-1;x++) if(m[y][x]===T.WAGE) count++;
      if(count<5){
        // respawn some wages on floor tiles
        for(let tries=0; tries<200 && count<7; tries++){
          const x=(Math.random()*(COLS-2)|0)+1;
          const y=(Math.random()*(ROWS-2)|0)+1;
          if(m[y][x]===T.FLOOR || m[y][x]===T.DOT){ m[y][x]=T.WAGE; count++; }
        }
      }
    }
  }

  // Draw scanlines
  function drawAll(){
    drawBackdrop(state);

    drawMap();

    // entities
    for(const b of buses) drawBus(b);
    for(const g of ghosts) drawGhost(g);
    drawPlayer();
    drawHUD();
    drawHelp();

    drawScanlines();
  }

  // Loop
  let now=0, last=0;
  function loop(ts){
    now = ts/1000;
    const dt = clamp((ts-last)/1000, 0, 0.033);
    last = ts;

    handleUI(dt);

    if(state===STATE.TITLE){
      drawBackdrop(STATE.WEST);
      overlay("SANTIAGO METRO ESCAPE", [
        "A Pac-style commute game about the exposome and brain health.",
        "Ghosts actively hunt you via shortest-path logic.",
        "Collect WAGES in the East, BANK them at Home in the West.",
        "Support pellets frighten ghosts. Tag them to send them to the depot.",
        "Press Enter to start. Press H for help."
      ]);
      drawScanlines();
      requestAnimationFrame(loop);
      return;
    }

    if(state===STATE.WEST || state===STATE.EAST){
      updatePlayer(dt);
      updateGhosts(dt);
      updateBuses(dt);
      applyDamage(dt);
      enforceGoal();
      updateMusic(dt);

      // banked progress is handled in pickups
      player.score += dt * 6.0;
    }

    if(state===STATE.GAMEOVER){
      drawBackdrop(state);
      drawMap();
      for(const b of buses) drawBus(b);
      for(const g of ghosts) drawGhost(g);
      drawPlayer();
      drawHUD();
      overlay("COGNITIVE COLLAPSE", [
        `Score: ${Math.floor(player.score)}`,
        `Wages delivered: ${banked}`,
        "",
        "Press Enter to restart"
      ]);
      drawScanlines();
      requestAnimationFrame(loop);
      return;
    }

    drawAll();
    requestAnimationFrame(loop);
  }

  // Patch pickups banking logic into handlePickups
  const _handlePickups = handlePickups;
  function handlePickups(){
    const m=curMap();
    const t=tileAt(m, player.x, player.y);

    if(t===T.DOT){
      m[player.y][player.x]=T.FLOOR;
      player.score += 2;
      sfx(720,0.03,0.020,"square",60);
    }

    if(t===T.WAGE){
      m[player.y][player.x]=T.FLOOR;
      player.carried += 1;
      player.score += 40;
      sfx(920,0.05,0.04,"square",80);
    }

    if(t===T.SUPPORT){
      m[player.y][player.x]=T.FLOOR;
      player.power.active=true;
      player.power.t=0;
      for(const g of ghosts){
        if(g.mode!=="EATEN") g.mode="FRIGHT";
      }
      sfx(660,0.10,0.05,"triangle",0);
      sfx(980,0.06,0.04,"square",0);
    }

    if(t===T.METRO){
      if(state===STATE.WEST){
        state=STATE.EAST;
        player.x = eastMetro.x;
        player.y = eastMetro.y+1;
      } else {
        state=STATE.WEST;
        player.x = westMetro.x;
        player.y = westMetro.y-1;
      }
      for(const g of ghosts){
        g.x = depot.x + (Math.random()<0.5?-3:3);
        g.y = depot.y + (Math.random()<0.5?-2:2);
        g.acc=0; g.lastDir={dx:0,dy:0};
        if(g.mode==="EATEN") g.mode="CHASE";
      }
      sfx(320,0.08,0.04,"triangle",-60);
      sfx(520,0.06,0.04,"square",60);
    }

    if(state===STATE.WEST && t===T.HOME && player.carried>0){
      banked += player.carried;
      player.score += player.carried*80;
      player.carried = 0;

      if(banked >= level.goalWages){
        player.score += 350;
        banked = 0;
        sfx(740,0.09,0.05,"square",90);
        sfx(520,0.12,0.05,"triangle",0);
      } else {
        sfx(520,0.08,0.04,"triangle",0);
      }
    }
  }

  resetAll();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
