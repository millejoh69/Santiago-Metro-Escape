<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Santiago Metro Escape - Pac Size</title>
  <style>
    html, body { margin:0; height:100%; background:#05080E; overflow:hidden; }
    #wrap { position:fixed; inset:0; display:grid; place-items:center; }
    canvas{
      width: min(92vw, 560px);
      height: auto;
      background:#000;
      border-radius: 14px;
      border: 1px solid rgba(232,241,255,0.14);
      box-shadow: 0 14px 42px rgba(0,0,0,0.40);
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }
    .hint{
      position:fixed; left:50%; transform:translateX(-50%); bottom:12px;
      font: 12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      color: rgba(232,241,255,0.9);
      padding:8px 12px; border-radius:999px;
      background: rgba(7,12,18,0.55);
      border: 1px solid rgba(232,241,255,0.14);
      max-width:min(560px,92vw);
      text-align:center;
    }
  </style>
</head>
<body>
  <div id="wrap"><canvas id="c" width="224" height="288"></canvas></div>
  <div class="hint">Move: WASD / Arrows • Help: H • Mute: M • Start: Enter</div>

<script>
(() => {
  const c = document.getElementById("c");
  const ctx = c.getContext("2d");

  const W = 224, H = 288;     // Pac-Man playfield pixels
  const TILE = 8;             // Pac-Man tile pixels
  const COLS = 28, ROWS = 36; // Pac-Man tile grid

  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const dist=(ax,ay,bx,by)=>Math.hypot(ax-bx, ay-by);

  // Input
  const keys = new Set();
  addEventListener("keydown", (e)=>{
    const k = (e.key===" " ? "space" : e.key.toLowerCase());
    keys.add(k);
    if(["arrowup","arrowdown","arrowleft","arrowright"," "].includes(e.key)) e.preventDefault();
  });
  addEventListener("keyup", (e)=>{
    const k = (e.key===" " ? "space" : e.key.toLowerCase());
    keys.delete(k);
  });

  // Audio (optional)
  let audioCtx=null, muted=false;
  function ensureAudio(){ if(!audioCtx) audioCtx=new (window.AudioContext||window.webkitAudioContext)(); }
  function sfx(freq=440, dur=0.06, vol=0.05, type="square", slide=0){
    if(muted) return;
    try{
      ensureAudio();
      const t0=audioCtx.currentTime;
      const o=audioCtx.createOscillator();
      const g=audioCtx.createGain();
      o.type=type;
      o.frequency.setValueAtTime(freq,t0);
      if(slide) o.frequency.linearRampToValueAtTime(freq+slide,t0+dur);
      g.gain.setValueAtTime(vol,t0);
      g.gain.exponentialRampToValueAtTime(0.0001,t0+dur);
      o.connect(g); g.connect(audioCtx.destination);
      o.start(t0); o.stop(t0+dur);
    }catch{}
  }

  const STATE={TITLE:"TITLE", WEST:"WEST", EAST:"EAST", GAMEOVER:"GAMEOVER"};
  let state=STATE.TITLE;
  let showHelp=true;

  const T={
    FLOOR:0, WALL:1, DOT:2, SUPPORT:3, METRO:4, SAFE:5, HOME:6, WAGE:7, ROAD:8
  };

  const PAL={
    ui:"#E8F1FF",
    bg:"#05080E",
    westFloor:"#071324",
    eastFloor:"#06182A",
    westWall:"#7FB1FF",
    eastWall:"#66D6FF",
    dot:"#CFE3FF",
    support:"#7CFFB5",
    wage:"#FFD66B",
    safe:"#7CFFB5",
    metro:"#FF8ED6",
    road:"#111C2F",
    roadLine:"rgba(255,214,107,0.55)",
  };

  function parse(lines){
    const m=[];
    for(let y=0;y<ROWS;y++){
      const row=[];
      const line=(lines[y]||"").padEnd(COLS," ");
      for(let x=0;x<COLS;x++){
        const ch=line[x];
        let v=T.FLOOR;
        if(ch==="#") v=T.WALL;
        else if(ch===".") v=T.DOT;
        else if(ch==="O") v=T.SUPPORT;
        else if(ch==="M") v=T.METRO;
        else if(ch==="S") v=T.SAFE;
        else if(ch==="H") v=T.HOME;
        else if(ch==="W") v=T.WAGE;
        else if(ch==="R") v=T.ROAD;
        row.push(v);
      }
      m.push(row);
    }
    return m;
  }

  // 36 rows, 28 columns
  const westLines = [
    "############################",
    "#............##............#",
    "#.####.#####.##.#####.####.#",
    "#O####.#####.##.#####.####O#",
    "#..........................#",
    "#.####.##.########.##.####.#",
    "#......##....##....##......#",
    "######.##### ## #####.######",
    "     #.##### ## #####.#     ",
    "######.##          ##.######",
    "#......## ###    ### ##.....#".slice(0,28),
    "#.####.## #      # ##.####.#",
    "#.####....#  ##  #....####.#",
    "#......## #  ##  # ##......#",
    "######.## ######## ##.######",
    "     #.##          ##.#     ",
    "######.## ######## ##.######",
    "#............##............#",
    "#.####.#####.##.#####.####.#",
    "#...##................##...#",
    "###.##.##.########.##.##.###",
    "#......##....##....##......#",
    "#.##########.##.##########.#",
    "#H.........#....#.........S#",
    "##########.#.MM.#.##########",
    "#..........#....#..........#",
    "#.##########.##.##########.#",
    "#......##....##....##......#",
    "###.##.##.########.##.##.###",
    "#...##................##...#",
    "#.####.#####.##.#####.####.#",
    "#............##............#",
    "#O####.#####.##.#####.####O#",
    "#............RR............#",
    "############################",
    "                            "
  ];

  const eastLines = [
    "############################",
    "#............##............#",
    "#.####.#####.##.#####.####.#",
    "#O####.#####.##.#####.####O#",
    "#..........W....W..........#",
    "#.####.##.########.##.####.#",
    "#......##....##....##......#",
    "######.##### ## #####.######",
    "     #.##### ## #####.#     ",
    "######.##          ##.######",
    "#..W...## ###    ### ##...W#",
    "#.####.## #      # ##.####.#",
    "#.####....#  ##  #....####.#",
    "#......## #  ##  # ##......#",
    "######.## ######## ##.######",
    "     #.##          ##.#     ",
    "######.## ######## ##.######",
    "#............##............#",
    "#.####.#####.##.#####.####.#",
    "#...##................##...#",
    "###.##.##.########.##.##.###",
    "#......##....##....##......#",
    "#.##########.##.##########.#",
    "#S.........#....#.........S#",
    "##########.#.MM.#.##########",
    "#..........#....#..........#",
    "#.##########.##.##########.#",
    "#......##....##....##......#",
    "###.##.##.########.##.##.###",
    "#...##................##...#",
    "#.####.#####.##.#####.####.#",
    "#............##............#",
    "#O####.#####.##.#####.####O#",
    "#............RR............#",
    "############################",
    "                            "
  ];

  const west = parse(westLines);
  const east = parse(eastLines);

  function curMap(){ return (state===STATE.WEST)?west:east; }
  function tileAt(m,x,y){ return (m[y] && m[y][x]!==undefined) ? m[y][x] : T.WALL; }
  function isWall(m,x,y){ return tileAt(m,x,y)===T.WALL; }

  const WRAP_ROW = 17;
  function canMove(m,x,y){
    if(y<0 || y>=ROWS) return false;
    if(x<0 || x>=COLS) return false;
    return !isWall(m,x,y);
  }
  function wrapX(x, y){
    if(y!==WRAP_ROW) return x;
    if(x<0) return COLS-1;
    if(x>=COLS) return 0;
    return x;
  }
  function findTile(m, tval){
    for(let y=0;y<ROWS;y++) for(let x=0;x<COLS;x++) if(m[y][x]===tval) return {x,y};
    return {x:1,y:1};
  }

  const depot = { x: 13, y: 12 };
  const westHome = findTile(west, T.HOME);
  const westMetro = findTile(west, T.METRO);
  const eastMetro = findTile(east, T.METRO);

  const player={
    x: westHome.x, y: westHome.y,
    hp:100, maxHp:100,
    carried:0,
    score:0,
    invuln:0,
    speed:10.0,
    power:{active:false,t:0,dur:7.0},
    dir:{dx:0,dy:0},
    want:{dx:0,dy:0}
  };
  let banked=0;

  function mkGhost(name,color,speed,start){
    return { name,color,speed, x:start.x,y:start.y, acc:0, mode:"CHASE", eatenTimer:0, lastDir:{dx:0,dy:0} };
  }
  const ghosts=[
    mkGhost("SMOG",  "#7CFFB5", 8.3, {x:depot.x,   y:depot.y}),
    mkGhost("SIREN", "#FFD66B", 8.7, {x:depot.x+1, y:depot.y}),
    mkGhost("HEAT",  "#FF6B87", 8.1, {x:depot.x-1, y:depot.y}),
    mkGhost("STRESS","#7FB1FF", 8.9, {x:depot.x,   y:depot.y+1}),
  ];

  const buses=[
    { x: 12, y: 33, acc:0, lastDir:{dx:1,dy:0}, color:"rgba(255,107,135,0.95)" },
    { x: 16, y: 33, acc:0, lastDir:{dx:-1,dy:0}, color:"rgba(255,214,107,0.95)" },
  ];

  const level={ dps:26, regen:10.0, safeRegenMul:2.6, safeDmgMul:0.55, goalWages:4 };

  function isSafe(m,x,y){
    const t=tileAt(m,x,y);
    return t===T.SAFE || t===T.HOME;
  }

  function drawBackdrop(){
    ctx.fillStyle=PAL.bg;
    ctx.fillRect(0,0,W,H);
  }

  function drawTile(m,x,y){
    const t=tileAt(m,x,y);
    const gx=x*TILE, gy=y*TILE;

    ctx.fillStyle = (state===STATE.WEST) ? PAL.westFloor : PAL.eastFloor;
    ctx.fillRect(gx,gy,TILE,TILE);

    if(t===T.ROAD){
      ctx.fillStyle=PAL.road;
      ctx.fillRect(gx,gy,TILE,TILE);
      ctx.globalAlpha=0.7;
      ctx.fillStyle=PAL.roadLine;
      ctx.fillRect(gx+1, gy+TILE/2, TILE-2, 1);
      ctx.globalAlpha=1;
      return;
    }
    if(t===T.WALL){
      ctx.fillStyle=(state===STATE.WEST)?PAL.westWall:PAL.eastWall;
      ctx.fillRect(gx,gy,TILE,TILE);
      ctx.globalAlpha=0.25;
      ctx.fillStyle="#000";
      ctx.fillRect(gx+1,gy+1,TILE-2,TILE-2);
      ctx.globalAlpha=1;
      return;
    }
    if(t===T.DOT){
      ctx.fillStyle=PAL.dot;
      ctx.fillRect(gx+3, gy+3, 2, 2);
      return;
    }
    if(t===T.SUPPORT){
      ctx.fillStyle=PAL.support;
      ctx.fillRect(gx+2, gy+2, 4, 4);
      ctx.globalAlpha=0.35;
      ctx.strokeStyle="rgba(124,255,181,0.9)";
      ctx.strokeRect(gx+1, gy+1, 6, 6);
      ctx.globalAlpha=1;
      return;
    }
    if(t===T.WAGE){
      ctx.fillStyle=PAL.wage;
      ctx.fillRect(gx+2, gy+2, 4, 4);
      return;
    }
    if(t===T.SAFE){
      ctx.globalAlpha=0.25;
      ctx.fillStyle=PAL.safe;
      ctx.fillRect(gx,gy,TILE,TILE);
      ctx.globalAlpha=1;
      ctx.strokeStyle="rgba(124,255,181,0.8)";
      ctx.strokeRect(gx+1, gy+1, 6, 6);
      return;
    }
    if(t===T.HOME){
      ctx.globalAlpha=0.35;
      ctx.fillStyle="#E8F1FF";
      ctx.fillRect(gx,gy,TILE,TILE);
      ctx.globalAlpha=1;
      ctx.fillStyle="#E8F1FF";
      ctx.fillRect(gx+2, gy+3, 4, 3);
      return;
    }
    if(t===T.METRO){
      ctx.globalAlpha=0.25;
      ctx.fillStyle=PAL.metro;
      ctx.fillRect(gx,gy,TILE,TILE);
      ctx.globalAlpha=1;
      ctx.fillStyle=PAL.metro;
      ctx.fillRect(gx+2, gy+1, 4, 6);
      return;
    }
  }

  function drawMap(){
    const m=curMap();
    for(let y=0;y<ROWS;y++) for(let x=0;x<COLS;x++) drawTile(m,x,y);

    const metro=(state===STATE.WEST)?westMetro:eastMetro;
    ctx.fillStyle="rgba(0,0,0,0.65)";
    ctx.fillRect(metro.x*TILE-6, metro.y*TILE-8, 44, 8);
    ctx.fillStyle=PAL.ui;
    ctx.font="7px ui-monospace, monospace";
    ctx.textBaseline="top";
    ctx.fillText("METRO", metro.x*TILE-4, metro.y*TILE-8);
  }

  function drawPlayer(){
    const x=player.x*TILE, y=player.y*TILE;
    ctx.fillStyle="rgba(59,228,197,0.95)";
    ctx.fillRect(x+1,y+1,6,6);
  }
  function drawGhost(g){
    const x=g.x*TILE, y=g.y*TILE;
    const frightened=(g.mode==="FRIGHT");
    const eaten=(g.mode==="EATEN");
    ctx.fillStyle = eaten ? "rgba(232,241,255,0.30)" : frightened ? "rgba(232,241,255,0.80)" : g.color;
    ctx.fillRect(x+1,y+1,6,6);
  }
  function drawBus(b){
    const x=b.x*TILE, y=b.y*TILE;
    ctx.fillStyle=b.color;
    ctx.fillRect(x, y+2, 8, 4);
  }

  function drawHUD(){
    ctx.fillStyle="rgba(0,0,0,0.55)";
    ctx.fillRect(0, 0, W, 16);
    ctx.fillStyle=PAL.ui;
    ctx.font="8px ui-monospace, monospace";
    ctx.textBaseline="middle";
    const side=(state===STATE.WEST) ? "WEST" : "EAST";
    ctx.fillText(`SIDE:${side} HP:${Math.ceil(player.hp)} CARRY:${player.carried} BANK:${banked}`, 4, 8);
  }

  function drawHelp(){
    if(!showHelp) return;
    ctx.fillStyle="rgba(0,0,0,0.78)";
    ctx.fillRect(12, 56, W-24, 120);
    ctx.strokeStyle="rgba(232,241,255,0.25)";
    ctx.strokeRect(12, 56, W-24, 120);

    ctx.fillStyle=PAL.ui;
    ctx.font="9px ui-monospace, monospace";
    ctx.textBaseline="top";
    const lines=[
      "WEST <-> EAST via METRO",
      "EAST: collect WAGES",
      "WEST: BANK at HOME",
      "Ghosts hunt you",
      "Support pellet scares them",
      "Safe tiles heal faster",
      "Enter starts, H toggles help"
    ];
    let y=64;
    for(const ln of lines){ ctx.fillText(ln, 18, y); y+=13; }
  }

  // BFS next step
  function bfsNextStep(m, sx, sy, tx, ty){
    if(sx===tx && sy===ty) return {dx:0,dy:0};
    const qx=new Int16Array(COLS*ROWS);
    const qy=new Int16Array(COLS*ROWS);
    const prev=new Int32Array(COLS*ROWS);
    prev.fill(-1);
    const idx=(x,y)=>y*COLS+x;

    let head=0, tail=0;
    qx[tail]=sx; qy[tail]=sy; tail++;
    prev[idx(sx,sy)]=idx(sx,sy);

    const dirs=[{dx:1,dy:0},{dx:-1,dy:0},{dx:0,dy:1},{dx:0,dy:-1}];

    while(head<tail){
      const x=qx[head], y=qy[head]; head++;
      if(x===tx && y===ty) break;

      for(const d of dirs){
        let nx = wrapX(x+d.dx, y);
        let ny = y+d.dy;
        nx = wrapX(nx, ny);

        if(ny<0 || ny>=ROWS) continue;
        if(nx<0 || nx>=COLS) continue;
        if(isWall(m,nx,ny)) continue;

        const ni=idx(nx,ny);
        if(prev[ni]!==-1) continue;
        prev[ni]=idx(x,y);
        qx[tail]=nx; qy[tail]=ny; tail++;
      }
    }

    const target=idx(tx,ty);
    if(prev[target]===-1) return {dx:0,dy:0};

    let cur=target;
    while(true){
      const p=prev[cur];
      if(p===cur) break;
      if(p===idx(sx,sy)){
        const cx=cur%COLS;
        const cy=Math.floor(cur/COLS);
        let dx=cx-sx, dy=cy-sy;
        if(dy===0 && sy===WRAP_ROW){
          if(sx===0 && cx===COLS-1) dx=-1;
          if(sx===COLS-1 && cx===0) dx=1;
        }
        return {dx: clamp(dx,-1,1), dy: clamp(dy,-1,1)};
      }
      cur=p;
    }
    return {dx:0,dy:0};
  }

  function ghostTarget(g){
    if(g.mode==="EATEN") return depot;
    if(g.mode==="FRIGHT"){
      const tx=(player.x < COLS/2) ? COLS-2 : 1;
      const ty=(player.y < ROWS/2) ? ROWS-2 : 1;
      return {x:tx,y:ty};
    }
    if(g.name==="SMOG") return {x:player.x,y:player.y};
    if(g.name==="SIREN") return {x: clamp(player.x+player.dir.dx*3,0,COLS-1), y: clamp(player.y+player.dir.dy*3,0,ROWS-1)};
    if(g.name==="HEAT"){
      const m=(state===STATE.WEST)?westMetro:eastMetro;
      return {x: Math.round((player.x+m.x)/2), y: Math.round((player.y+m.y)/2)};
    }
    return {x: clamp(player.x + (Math.random()<0.5?1:-1),0,COLS-1), y: player.y};
  }

  function updateGhosts(dt){
    const m=curMap();
    for(const g of ghosts){
      if(g.mode==="EATEN"){
        g.eatenTimer -= dt;
        if(g.eatenTimer<=0){ g.mode="CHASE"; g.x=depot.x; g.y=depot.y; g.acc=0; }
      }
      let spd=g.speed;
      if(g.mode==="FRIGHT") spd *= 0.72;
      if(g.mode==="EATEN") spd *= 1.6;

      g.acc += dt*spd;
      while(g.acc>=1){
        g.acc -= 1;
        const tgt=ghostTarget(g);
        const step=bfsNextStep(m, g.x, g.y, tgt.x, tgt.y);
        let nx=wrapX(g.x+step.dx, g.y);
        let ny=g.y+step.dy;
        nx=wrapX(nx, ny);
        if(canMove(m,nx,ny)){ g.x=nx; g.y=ny; g.lastDir=step; }
      }
    }
  }

  function isRoad(m,x,y){ return tileAt(m,x,y)===T.ROAD; }
  function updateBuses(dt){
    const m=curMap();
    for(const b of buses){
      b.acc += dt*7.2;
      while(b.acc>=1){
        b.acc -= 1;
        const dirs=[{dx:b.lastDir.dx,dy:b.lastDir.dy},{dx:1,dy:0},{dx:-1,dy:0},{dx:0,dy:1},{dx:0,dy:-1}];
        let chosen=null;
        for(const d of dirs){
          let nx=wrapX(b.x+d.dx, b.y);
          let ny=b.y+d.dy;
          nx=wrapX(nx, ny);
          if(ny<0 || ny>=ROWS) continue;
          if(nx<0 || nx>=COLS) continue;
          if(isRoad(m,nx,ny)){ chosen={nx,ny,dx:d.dx,dy:d.dy}; break; }
        }
        if(!chosen){ b.lastDir={dx:-b.lastDir.dx, dy:-b.lastDir.dy}; continue; }
        b.x=chosen.nx; b.y=chosen.ny; b.lastDir={dx:chosen.dx,dy:chosen.dy};
      }
    }
  }

  function handlePickups(){
    const m=curMap();
    const t=tileAt(m, player.x, player.y);

    if(t===T.DOT){ m[player.y][player.x]=T.FLOOR; sfx(720,0.02,0.01,"square",40); }
    if(t===T.WAGE){ m[player.y][player.x]=T.FLOOR; player.carried++; sfx(920,0.04,0.03,"square",80); }

    if(t===T.SUPPORT){
      m[player.y][player.x]=T.FLOOR;
      player.power.active=true; player.power.t=0;
      for(const g of ghosts) if(g.mode!=="EATEN") g.mode="FRIGHT";
      sfx(660,0.08,0.04,"triangle",0);
    }

    if(t===T.METRO){
      if(state===STATE.WEST){ state=STATE.EAST; player.x=eastMetro.x; player.y=eastMetro.y+1; }
      else { state=STATE.WEST; player.x=westMetro.x; player.y=westMetro.y-1; }
      for(const g of ghosts){ g.x=depot.x; g.y=depot.y; g.mode="CHASE"; g.acc=0; }
      sfx(520,0.05,0.03,"square",60);
    }

    if(state===STATE.WEST && t===T.HOME && player.carried>0){
      banked += player.carried; player.carried=0;
      sfx(520,0.06,0.03,"triangle",0);
      if(banked>=level.goalWages){ banked=0; sfx(740,0.08,0.04,"square",90); }
    }
  }

  let moveAcc=0;
  function updatePlayer(dt){
    const m=curMap();
    moveAcc += dt*player.speed;

    if(keys.has("arrowleft")||keys.has("a")) player.want={dx:-1,dy:0};
    else if(keys.has("arrowright")||keys.has("d")) player.want={dx:1,dy:0};
    else if(keys.has("arrowup")||keys.has("w")) player.want={dx:0,dy:-1};
    else if(keys.has("arrowdown")||keys.has("s")) player.want={dx:0,dy:1};

    while(moveAcc>=1){
      moveAcc -= 1;

      if(player.want.dx || player.want.dy){
        const tx=wrapX(player.x+player.want.dx, player.y);
        const ty=player.y+player.want.dy;
        if(ty>=0 && ty<ROWS && canMove(m, wrapX(tx,ty), ty)) player.dir={...player.want};
      }

      let nx=wrapX(player.x+player.dir.dx, player.y);
      let ny=player.y+player.dir.dy;
      nx=wrapX(nx, ny);

      if(ny>=0 && ny<ROWS && canMove(m,nx,ny)){ player.x=nx; player.y=ny; }
      handlePickups();
    }
  }

  function applyDamage(dt){
    const m=curMap();

    if(player.invuln>0) player.invuln -= dt; // FIXED

    if(player.power.active){
      player.power.t += dt;
      if(player.power.t>=player.power.dur){
        player.power.active=false;
        for(const g of ghosts) if(g.mode==="FRIGHT") g.mode="CHASE";
      }
    }

    const px=player.x*TILE+4, py=player.y*TILE+4;

    let busNear=false;
    for(const b of buses){
      const bx=b.x*TILE+4, by=b.y*TILE+4;
      if(dist(px,py,bx,by)<12){ busNear=true; break; }
    }

    const safe=isSafe(m, player.x, player.y);

    let hit=null;
    for(const g of ghosts){
      const gx=g.x*TILE+4, gy=g.y*TILE+4;
      if(dist(px,py,gx,gy)<6){ hit=g; break; }
    }

    if(hit && player.power.active && hit.mode==="FRIGHT"){
      hit.mode="EATEN"; hit.eatenTimer=1.4; hit.x=depot.x; hit.y=depot.y;
      player.invuln=0.12;
      sfx(980,0.05,0.04,"square",120);
      return;
    }

    let dmgMul=1.0;
    if(busNear) dmgMul*=1.12;
    if(safe) dmgMul*=level.safeDmgMul;

    if(hit && player.invuln<=0 && hit.mode!=="EATEN"){
      player.hp -= level.dps*dmgMul*dt;
      player.invuln=0.22;
      sfx(240,0.03,0.03,"square",-30);
    } else {
      const regen=level.regen*(safe?level.safeRegenMul:1.0);
      player.hp += regen*dt;
    }

    player.hp=clamp(player.hp,0,player.maxHp);
    if(player.hp<=0) state=STATE.GAMEOVER;
  }

  function overlayTitle(){
    drawBackdrop();
    ctx.fillStyle="rgba(0,0,0,0.70)";
    ctx.fillRect(0, 84, W, 104);
    ctx.fillStyle=PAL.ui;
    ctx.font="12px ui-monospace, monospace";
    ctx.textAlign="center"; ctx.textBaseline="middle";
    ctx.fillText("SANTIAGO METRO ESCAPE", W/2, 110);
    ctx.font="9px ui-monospace, monospace";
    ctx.fillText("Enter to start", W/2, 132);
    ctx.fillText("If this shows, the game is running", W/2, 154);
    ctx.textAlign="left";
  }

  function resetAll(){
    state=STATE.WEST;
    player.x=westHome.x; player.y=westHome.y;
    player.hp=100; player.carried=0; player.invuln=0;
    player.power.active=false; player.power.t=0;
    player.dir={dx:0,dy:0}; player.want={dx:0,dy:0};
    banked=0;
    const starts=[{x:depot.x,y:depot.y},{x:depot.x+1,y:depot.y},{x:depot.x-1,y:depot.y},{x:depot.x,y:depot.y+1}];
    ghosts.forEach((g,i)=>{ g.x=starts[i].x; g.y=starts[i].y; g.mode="CHASE"; g.acc=0; });
  }

  let last=0;
  function loop(ts){
    const now=ts/1000;
    const dt=clamp((ts-last)/1000, 0, 0.033);
    last=ts;

    if(keys.has("m")){ keys.delete("m"); muted=!muted; sfx(muted?160:760,0.05,0.04,"square",0); }
    if(keys.has("h")){ keys.delete("h"); showHelp=!showHelp; sfx(620,0.03,0.03,"square", showHelp?40:-40); }

    if(keys.has("enter")){
      keys.delete("enter");
      if(state===STATE.TITLE){ state=STATE.WEST; showHelp=false; try{ ensureAudio(); }catch{} }
      else if(state===STATE.GAMEOVER){ resetAll(); state=STATE.WEST; showHelp=false; }
    }

    if(state===STATE.TITLE){
      overlayTitle();
      requestAnimationFrame(loop);
      return;
    }

    if(state===STATE.WEST || state===STATE.EAST){
      updatePlayer(dt);
      updateGhosts(dt);
      updateBuses(dt);
      applyDamage(dt);
    }

    drawBackdrop();
    drawMap();
    for(const b of buses) drawBus(b);
    for(const g of ghosts) drawGhost(g);
    drawPlayer();
    drawHUD();
    drawHelp();

    if(state===STATE.GAMEOVER){
      ctx.fillStyle="rgba(0,0,0,0.70)";
      ctx.fillRect(0, 84, W, 104);
      ctx.fillStyle=PAL.ui;
      ctx.font="12px ui-monospace, monospace";
      ctx.textAlign="center"; ctx.textBaseline="middle";
      ctx.fillText("GAME OVER", W/2, 120);
      ctx.font="9px ui-monospace, monospace";
      ctx.fillText("Press Enter", W/2, 146);
      ctx.textAlign="left";
    }

    requestAnimationFrame(loop);
  }

  resetAll();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
